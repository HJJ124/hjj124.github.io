<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astro的踩坑记录</title>
  
  
  <link href="https://ihjj.cn/atom.xml" rel="self"/>
  
  <link href="https://ihjj.cn/"/>
  <updated>2022-09-02T10:26:34.403Z</updated>
  <id>https://ihjj.cn/</id>
  
  <author>
    <name>Junjie Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 笔记</title>
    <link href="https://ihjj.cn/2022/09/02/Docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://ihjj.cn/2022/09/02/Docker%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-02T10:26:34.403Z</published>
    <updated>2022-09-02T10:26:34.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dcoker是什么"><a href="#Dcoker是什么" class="headerlink" title="Dcoker是什么"></a>Dcoker是什么</h2><h4 id="容器化技术-直接运行在操作系统上（宿主机内核中）没有虚拟硬件-内核级别虚拟化-轻便-每个容器间互相隔离-各有自己的文件系统-通过镜像生成容器"><a href="#容器化技术-直接运行在操作系统上（宿主机内核中）没有虚拟硬件-内核级别虚拟化-轻便-每个容器间互相隔离-各有自己的文件系统-通过镜像生成容器" class="headerlink" title="容器化技术 直接运行在操作系统上（宿主机内核中）没有虚拟硬件  内核级别虚拟化 轻便 每个容器间互相隔离 各有自己的文件系统 通过镜像生成容器"></a><strong>容器化技术 直接运行在操作系统上（宿主机内核中）没有虚拟硬件  内核级别虚拟化 轻便 每个容器间互相隔离 各有自己的文件系统 通过镜像生成容器</strong></h4><p>所有docker镜像都是只读，在镜像启动时加载一个新的可写层至镜像层顶部，即为容器层。<br><img src="/2022/09/02/Docker%E7%AC%94%E8%AE%B0/Clenk.png" alt="8f136c933dba31d015eca1c9526d6457.jpeg"><br><img src="/2022/09/02/Docker%E7%AC%94%E8%AE%B0/Docker.jpg" alt="4e473c94c8e44c6ea223b214642cdb35.png"></p><h2 id="Docker入门命令"><a href="#Docker入门命令" class="headerlink" title="Docker入门命令"></a>Docker入门命令</h2><h3 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h3><p>所有命令可在<a href="https://docs.docker.com/engine/reference/run/">Docker命令官方文档</a>中查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一条通用原则</span></span><br><span class="line">docker cmd --<span class="built_in">help</span> <span class="comment"># 查看cmd支持的常用命令 完整版在官方文档搜索 </span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker info         <span class="comment">#显示docker系统信息 包括镜像、容器数量</span></span><br><span class="line">docker search xxx   <span class="comment"># 查询镜像</span></span><br><span class="line">docker run 镜像<span class="built_in">id</span> [cmd]      <span class="comment"># 生成容器并运行命令</span></span><br><span class="line">docker ps          <span class="comment"># 查看所有容器</span></span><br><span class="line">docker images       <span class="comment"># 查看所有镜像</span></span><br><span class="line">docker top 容器<span class="built_in">id</span>       <span class="comment"># 查看容器内进程</span></span><br><span class="line">docker inspect 容器<span class="built_in">id</span>       <span class="comment"># 查看容器所有信息 包括容器内的默认环境...</span></span><br><span class="line">docker <span class="built_in">rm</span>  xxx     <span class="comment"># 删除容器</span></span><br><span class="line">docker rmi xxx     <span class="comment"># 删除镜像（i-&gt;images）</span></span><br><span class="line">docker start/restart/stop/kill 容器<span class="built_in">id</span>   <span class="comment">#开启/重启/结束/关闭 容器</span></span><br><span class="line">docker logs        <span class="comment">#查看log文件</span></span><br><span class="line">docker <span class="built_in">history</span> 镜像<span class="built_in">id</span>  <span class="comment">#查看镜像创建的历史及步骤</span></span><br><span class="line">docker stats <span class="comment">#查看所有容器的cpu占用等信息</span></span><br><span class="line">docker commmit -m=<span class="string">&quot;commited_information&quot;</span> -a=<span class="string">&quot;author_name&quot;</span> 容器<span class="built_in">id</span> name:tag</span><br><span class="line">docker push    <span class="comment">#发布镜像（docker hub 阿里云）</span></span><br></pre></td></tr></table></figure><p>进入容器后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>         <span class="comment"># 退出并关闭容器</span></span><br><span class="line">ctrl+p+q     <span class="comment"># 退出容器 保持后台运行</span></span><br></pre></td></tr></table></figure><p>通常将容器放在后台运行，此时如果需要进入当前正在运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> 进入后执行的命令   <span class="comment">#(通常执行bash)  </span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span>       <span class="comment">#如果容器正在执行文件或有持续输出，则持续显示输出信息</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关于宿主机与容器的文件交换"><a href="#关于宿主机与容器的文件交换" class="headerlink" title="关于宿主机与容器的文件交换"></a>关于宿主机与容器的文件交换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 手动从容器拷贝文件到主机（只要容器在数据就在，无论是否运行，即docker ps -a存在即可）：</span></span><br><span class="line"><span class="comment"># 先进入容器</span></span><br><span class="line">docker attach 容器<span class="built_in">id</span> </span><br><span class="line"><span class="comment">#然后复制文件</span></span><br><span class="line">docker <span class="built_in">cp</span> 容器<span class="built_in">id</span>:/path/of/docker /path/of/linux</span><br><span class="line"><span class="comment"># 2. 在创建容器时挂载文件到容器内，实现双向同步</span></span><br><span class="line">docker run -it -v /path/of/local:/path/of/docker 镜像名称 bash</span><br></pre></td></tr></table></figure><p>数据共享（目录挂载）时，将容器内的目录挂载到linux上，以实现容器的持久化和同步操作。容器之间的数据也可以共享。<br>可通过以下方式查看挂载信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器<span class="built_in">id</span></span><br><span class="line">[</span><br><span class="line">...</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/home/hjj&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/tmp&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>-v后宿主机路径与容器路径会绑定，若本机不存在此路径则新建，文件双向绑定同步，即使exit退出容器只要镜像还在(docker ps -a)即可在本地修改文件并在容器中同步。即使删除容器，改变的数据文件已存在本地，所以不会丢失。<br>通过以下命令重新进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start  容器<span class="built_in">id</span></span><br><span class="line">docker attatch 容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h4 id="文件挂载的两种方式"><a href="#文件挂载的两种方式" class="headerlink" title="文件挂载的两种方式"></a>文件挂载的两种方式</h4><h5 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径</span><br><span class="line">docker volume <span class="built_in">ls</span>  <span class="comment"># 查看所有卷，由于-v之后为给定本机路径，因此输出的 VOLUME NAME 为英文+数子的长字符串</span></span><br></pre></td></tr></table></figure><h5 id="具名挂载-（常用）"><a href="#具名挂载-（常用）" class="headerlink" title="具名挂载 （常用）"></a>具名挂载 （常用）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v name:容器内路径  <span class="comment"># name中不包含/，否则表示本机路径 </span></span><br><span class="line">docker volume inspect name  <span class="comment">#查看卷</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v /path/of/local:容器内路径 <span class="comment">#表示指定路径挂载</span></span><br><span class="line"><span class="comment"># 未指定目录的情况下挂载在本机/var/lib/docker</span></span><br></pre></td></tr></table></figure><p>容器内路径后可通过 <strong>:ro rw</strong> 来改变读写权限，表示只读&#x2F;只写，ro表示容器中此路径只能通过宿主机操作</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile官方说明</a><br>用于构建docker的构建文件，为命令脚本,通过docker build构建成为镜像。很多官方镜像都是基础包（FROM scratch)，缺乏很多功能如vim，因此通常自己制作镜像。<br>面向开发，通常用于发布项目&#x2F;做镜像，镜像已逐渐成为企业交付的标准。DockerImages通过DockerFile生成的镜像 最终发布和运行的产品。<br>Dockerfile中关键字建议大写，指令小写，用 <strong>#</strong> 注释。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>                     <span class="comment"># 基础镜像 从此开始构建</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>        <span class="comment"># 维护者 姓名➕邮箱</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">                        <span class="comment"># 构建镜像时需要运行的命令</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash">                        <span class="comment"># 可将压缩包自动解压到容器指定路径下  ADD xxx.tgz /path</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash">             <span class="comment"># 镜像的工作目录</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash">               <span class="comment"># 挂载的目录</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>                <span class="comment"># 同-p  暴露端口</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">                      <span class="comment"># 指定容器启动时运行的命令  只有最后一个会生效，可被替代 可通过&amp;&amp;执行多个命令</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash">    <span class="comment"># 指定容器启动时运行的命令 可以追加</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>             <span class="comment"># 当构建一个被继承的dockerfile时，ONBUILD就会运行</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">                    <span class="comment"># 类似ADD  将文件拷贝到镜像中</span></span></span><br><span class="line"><span class="keyword">ENV</span>                       <span class="comment"># 构建时设置环境变了</span></span><br></pre></td></tr></table></figure><p>通过以下命令创建镜像。注意最后的 <strong>.</strong> 表示当前路径不要遗漏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerfile_name -t 镜像名[:tag]  .</span><br></pre></td></tr></table></figure><p>若命名为Dockerfile可省去-f dockerfile_name的指令。</p><h4 id="Dockerfile中CMD与ENTRYPOINT区别"><a href="#Dockerfile中CMD与ENTRYPOINT区别" class="headerlink" title="Dockerfile中CMD与ENTRYPOINT区别"></a>Dockerfile中CMD与ENTRYPOINT区别</h4><p>对于dockerfile创建的镜像，可通过以下命令来指定运行容器后需要执行的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像<span class="built_in">id</span> [cmd] </span><br></pre></td></tr></table></figure><p>此cmd会覆盖Dockefile中CMD指定的命令，而对于ENTRYPOINT指定的命令，cmd会追加在命令后执行，不会忽略。</p><h3 id="镜像发布"><a href="#镜像发布" class="headerlink" title="镜像发布"></a>镜像发布</h3><p>可将打包好的镜像发布至 <strong><a href="https://hub.docker.com/">docker官网镜像网站</a></strong> 供他人下载，也可以在此寻找别人打包好的镜像。<br>在提交到hub之前必须给镜像加上tag:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] hub_username/TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><p>hub_username为docker账号的用户名，且提交前必须在镜像前加上此字段，然后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push hub_username/TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><p>即可在镜像网站中登陆查看到。<br>也可以推送至阿里云（收费托管）</p><h3 id="个人常用命令"><a href="#个人常用命令" class="headerlink" title="个人常用命令"></a>个人常用命令</h3><p>从tensorflow官网拉取镜像运行tf-GPU(若GPU设备足够(算力(Compute Capability)大于5.2)可使用<a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/tensorflow">NVIDIA-docker官网的TensorFlow镜像</a>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --gpus all -it --<span class="built_in">rm</span>  -v <span class="variable">$PWD</span>:/tmp -w /tmp tensorflow/tensorflow:latest-gpu bash</span><br></pre></td></tr></table></figure><p>需要手动安装scipy&#x2F;matplotlib&#x2F;vim等库&#x2F;软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a        <span class="comment">#正在以及历史运行的容器</span></span><br><span class="line">docker ps -a -n=1   <span class="comment">#只显示一个</span></span><br><span class="line">docker ps -aq -n=1  <span class="comment">#只显示一个并只显示id</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq) <span class="comment">#查询所有容器id并逐个删除容器</span></span><br><span class="line"></span><br><span class="line">docker logs -tf -<span class="built_in">tail</span> n <span class="comment">#带时间戳查看最新n个log</span></span><br></pre></td></tr></table></figure><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名  <span class="comment"># 对于某些镜像，在docker ps时不会找到，因为后台运行时必须要有一个前台进程  否则docker发现没有应用会自动停止</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dcoker是什么&quot;&gt;&lt;a href=&quot;#Dcoker是什么&quot; class=&quot;headerlink&quot; title=&quot;Dcoker是什么&quot;&gt;&lt;/a&gt;Dcoker是什么&lt;/h2&gt;&lt;h4 id=&quot;容器化技术-直接运行在操作系统上（宿主机内核中）没有虚拟硬件-内核级别虚拟</summary>
      
    
    
    
    <category term="Linux" scheme="https://ihjj.cn/categories/Linux/"/>
    
    
    <category term="Software" scheme="https://ihjj.cn/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04 下cesm1.1 的移植与测试</title>
    <link href="https://ihjj.cn/2022/05/23/CESM_1.1/"/>
    <id>https://ihjj.cn/2022/05/23/CESM_1.1/</id>
    <published>2022-05-23T02:50:35.000Z</published>
    <updated>2022-09-02T10:07:31.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开始之前先要安装库以及相应软件，过程省略，具体在官网：<br><a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/usersguide/book1.html">CESM1.1.z User’s Guide</a><br><a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/usersguide/x21.html#software_system_prerequisites">CESM Software&#x2F;Operating System Prerequisites</a>.<br>CESM各个版本：<a href="https://www.cesm.ucar.edu/models/?ref=hp">CESM Models</a><br>也可在github中下载:<br><a href="https://github.com/ESCOMP/CESM">GitHub-ESCOMP&#x2F;CESM: The Community Earth System ModelThe Community Earth System Model.</a></p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>本文重点在于source code移植后的修改配置部分<br>假设模式位于 <strong>cesm1_1&#x2F;</strong><br>需要修改的文件均位于 <strong>cesm1_1&#x2F;scripts&#x2F;ccsm_utils&#x2F;Machines</strong> 路径下</p><h4 id="config-machines-xml"><a href="#config-machines-xml" class="headerlink" title="config_machines.xml"></a><strong>config_machines.xml</strong></h4><p>主要是修改关于机器的配置<br>添加以下部分 （根据自己服务器的配置&#x2F;环境来配置。具体各项意义可见官网<a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/modelnl/">CESM Models | CESM1.1 Public Release</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;machine MACH=<span class="string">&quot;ubuntu&quot;</span>&gt;</span><br><span class="line">        &lt;DESC&gt;my ubuntu 20.04&lt;/DESC&gt;</span><br><span class="line">        &lt;OS&gt;LINUX&lt;/OS&gt;</span><br><span class="line">        &lt;COMPILERS&gt;intel,pgi,gnu,pathscale&lt;/COMPILERS&gt;</span><br><span class="line">        &lt;MPILIBS&gt;mpich,mpi,pempi,mpi-serial&lt;/MPILIBS&gt;</span><br><span class="line">        &lt;RUNDIR&gt;/xxxxxxxxx/cesm1_1/<span class="variable">$CASE</span>/run&lt;/RUNDIR&gt;</span><br><span class="line">        &lt;EXEROOT&gt;/xxxxxxxx/cesm1_1/<span class="variable">$CASE</span>/bld&lt;/EXEROOT&gt;</span><br><span class="line">        &lt;DIN_LOC_ROOT&gt;/xxxxxx/Cesm_data/inputdata&lt;/DIN_LOC_ROOT&gt;&lt;DIN_LOC_ROOT_CLMFORC&gt;xxxxxxx/Cesm_data/tss&lt;/DIN_LOC_ROOT_CLMFORC&gt;</span><br><span class="line">        &lt;DOUT_S_ROOT&gt;xxxxxx/cesm1_1/<span class="variable">$CASE</span>/output&lt;/DOUT_S_ROOT&gt;</span><br><span class="line">        &lt;DOUT_L_MSROOT&gt;csm/<span class="variable">$CASE</span>&lt;/DOUT_L_MSROOT&gt;&lt;CCSM_BASELINE&gt;<span class="variable">$ENV</span>&#123;CESMDATAROOT&#125;/ccsm_baselines&lt;/CCSM_BASELINE&gt;&lt;CCSM_CPRNC&gt;<span class="variable">$ENV</span>&#123;CESMDATAROOT&#125;/tools/cprnc/cprnc&lt;/CCSM_CPRNC&gt;</span><br><span class="line">        &lt;BATCHQUERY&gt;USERDEFINED_optional_run&lt;/BATCHQUERY&gt;</span><br><span class="line">        &lt;BATCHSUBMIT&gt;USERDEFINED_optional_run&lt;/BATCHSUBMIT&gt;&lt;SUPPORTED_BY&gt;USERDEFINED_optional_run&lt;/SUPPORTED_BY&gt;</span><br><span class="line">        &lt;GMAKE_J&gt;1&lt;/GMAKE_J&gt;</span><br><span class="line">        &lt;MAX_TASKS_PER_NODE&gt;2&lt;/MAX_TASKS_PER_NODE&gt;</span><br><span class="line">        &lt;PES_PER_NODE&gt;1&lt;/PES_PER_NODE&gt;</span><br><span class="line">&lt;/machine&gt;</span><br></pre></td></tr></table></figure><h4 id="config-compilers-xml"><a href="#config-compilers-xml" class="headerlink" title="config_compilers.xml"></a><strong>config_compilers.xml</strong></h4><p>关于编译器的配置<br>添加以下部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;compiler COMPILER=<span class="string">&quot;intel&quot;</span> MACH=<span class="string">&quot;ubuntu&quot;</span>&gt;</span><br><span class="line"> &lt;NETCDF_PATH&gt;$(NETCDF)&lt;/NETCDF_PATH&gt;</span><br><span class="line"> &lt;MPICC&gt;mpiicc&lt;/MPICC&gt;</span><br><span class="line"> &lt;MPIFC&gt;mpiifort&lt;/MPIFC&gt;</span><br><span class="line"> &lt;MPICXX&gt;mpicpc&lt;/MPICXX&gt;</span><br><span class="line"> &lt;SFC&gt;ifort&lt;/SFC&gt;</span><br><span class="line"> &lt;SCC&gt;icc&lt;/SCC&gt;</span><br><span class="line"> &lt;SCXX&gt;icpc&lt;/SCXX&gt;</span><br><span class="line"> &lt;MPI_PATH MPILIB=<span class="string">&quot;mpich&quot;</span>&gt; /opt/intel/oneapi/mpi/2021.2.0&lt;/MPI_PATH&gt;</span><br><span class="line"> &lt;MPI_PATH MPILIB=<span class="string">&quot;openmpi&quot;</span>&gt; /opt/intel/oneapi/mpi/2021.2.0&lt;/MPI_PATH&gt;</span><br><span class="line"> &lt;HDF5_PATH&gt;$(NETCDF)&lt;/HDF5_PATH&gt;</span><br><span class="line"> &lt;ADD_SLIBS&gt; -L$(NETCDF_PATH)/lib -lnetcdff -lnetcdf -L$(HDF5_PATH)/lib -lhdf5 -lhdf5_hl &lt;/ADD_SLIBS&gt;</span><br><span class="line">&lt;/compiler&gt;</span><br></pre></td></tr></table></figure><h4 id="env-mach-specific-userdefined"><a href="#env-mach-specific-userdefined" class="headerlink" title="env_mach_specific.userdefined"></a><strong>env_mach_specific.userdefined</strong></h4><p>将 <strong>env_mach_specific.userdefined</strong>  复制为  <strong>env_mach_specific.ubuntu</strong><br>点后面（ubuntu）为之前设置的MACH名称<br>添加以下部分，注意 set 后面有&#x3D;，且&#x3D;前后有空格。setenv没有等号，只有空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set NETCDF_PATH = /usr/local/netcdf-ifort</span><br><span class="line">set MPI_PATH = /opt/intel/oneapi/mpi/2021.2.0</span><br><span class="line">setenv INC_NETCDF $&#123;NETCDF_PATH&#125;/include</span><br><span class="line">setenv LIB_NETCDF $&#123;NETCDF_PATH&#125;/lib</span><br><span class="line">setenv INC_MPI $&#123;MPI_PATH&#125;/include</span><br><span class="line">setenv LIB_MPI $&#123;MPI_PATH&#125;/lib</span><br></pre></td></tr></table></figure><h4 id="mkbatch-userdefined"><a href="#mkbatch-userdefined" class="headerlink" title="mkbatch.userdefined"></a>mkbatch.userdefined</h4><p>将 <strong>mkbatch.userdefined</strong> 复制为 <strong>mkbatch.ubuntu</strong><br>点后面依旧是之前设置的MACH名称<br>根据服务器提交作业的方式把qname&#x3D;batch 为自己服务器的脚本提交方式，如 qname&#x3D;qnormal，并把下方##的代码根据提交任务的脚本 去掉注释即可 （包括mpirun等等命令所在的行)</p><h3 id="完成移植，进行测试。"><a href="#完成移植，进行测试。" class="headerlink" title="完成移植，进行测试。"></a>完成移植，进行测试。</h3><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>此测试来自官方网站：<a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/usersguide/c1986.html#use_case_basic">Use Cases and FAQs</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> cesm1_1/scripts</span><br><span class="line">./create_newcase -<span class="keyword">case</span>  case_official \</span><br><span class="line">                 -compset B_1850_CN \</span><br><span class="line">                 -res 0.9x1.25_gx1v6 \</span><br><span class="line">                 -mach ubuntu</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> case_official/</span><br></pre></td></tr></table></figure><p>此时可根据需要修改运行配置如大气模式用到的核数  NTASKS_ATM …..  （当前该变量值可通过以下命令查询到。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xmlquery NTASKS_ATM  </span><br></pre></td></tr></table></figure><p>对于修改诸如模式要用的核数<strong>NTASKS_xxxxx</strong>、线程数<strong>NTHRDS_xxx</strong>等等<strong>env_mach_pes.xml</strong>中的变量，必须在.&#x2F;cesm_setup之前修改，如果setup之后修改，必须先.&#x2F;cesm_setup -clean，修改，然后重新.&#x2F;cesm_setup。<br>对于诸如任务重新提交时间<strong>STOP_OPTION</strong>等等其他变量，可在.&#x2F;cesm_setup之后修改<br>两种修改方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1  ./xmlchange NTASKS_ATM=64   （等价于 ./xmlchange -file env_mach_pes.xml -<span class="built_in">id</span> NTASKS_ATM -val 64）</span><br></pre></td></tr></table></figure><p>2      直接vim修改<strong>env_mach_pes.xml</strong> 或是其余xml文件<br>同上，所有与运行相关的配置变量可在<a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/modelnl/">CESM Models | CESM1.1 Public Release</a>通过对应xml文件查找到。</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./cesm_setup</span><br><span class="line">./case_official.build</span><br></pre></td></tr></table></figure><p>生成测试脚本（测试本例子能否跑通）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./create_production_test</span><br><span class="line"><span class="built_in">cd</span> ../case_official_ERT</span><br><span class="line">./case_official_ERT.test_build</span><br><span class="line">./case_official_ERT.<span class="built_in">test</span></span><br><span class="line"><span class="built_in">cat</span> CaseStatus    (官网为 <span class="built_in">cat</span> TestStatus ，以实际为准)</span><br></pre></td></tr></table></figure><p>如果没有问题（PASS）即可进行下一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../case_official</span><br><span class="line">./xmlchange STOP_OPTION=nmonths   注意修改方式与官网给出的不一致</span><br><span class="line">./xmlchange STOP_N=12</span><br><span class="line">bsub &lt; case_official.run   提交作业方法因服务器而异</span><br></pre></td></tr></table></figure><p>之后可在out文件中查看是否成功</p><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><h5 id="创建一个分辨率为10-amp-deg-x15-amp-deg-，只运行大气模块的试验"><a href="#创建一个分辨率为10-amp-deg-x15-amp-deg-，只运行大气模块的试验" class="headerlink" title="创建一个分辨率为10&amp;deg;x15&amp;deg;，只运行大气模块的试验"></a>创建一个分辨率为10&amp;deg;x15&amp;deg;，只运行大气模块的试验</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./create_newcase -<span class="keyword">case</span> coarse_amip -compset  FAMIPC5 -res 10x15_10x15  -mach ubuntu</span><br><span class="line"><span class="built_in">cd</span> coarse_amip</span><br><span class="line">./cesm_setup</span><br><span class="line">./coarse_amip.build</span><br></pre></td></tr></table></figure><h5 id="生成测试的试运行脚本"><a href="#生成测试的试运行脚本" class="headerlink" title="生成测试的试运行脚本"></a>生成测试的试运行脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./create_production_test</span><br><span class="line"><span class="built_in">cd</span> ../coarse_amip._ERT</span><br><span class="line">./coarse_amip_ERT.build</span><br><span class="line">./coarse_amip_ERT.run</span><br><span class="line"><span class="built_in">cat</span> TestStatus</span><br></pre></td></tr></table></figure><h5 id="修改运行设置"><a href="#修改运行设置" class="headerlink" title="修改运行设置"></a>修改运行设置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../coarse_amip</span><br></pre></td></tr></table></figure><p>设置例如积分时长，运行月份，变量输出频率的配置<br>对于自定义输出，可见: <a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/usersguide/x2280.html">CAM: How do I customize CAM output fields?</a><br>在 <strong>user_nl_xxx</strong> 中修改xxx（如CAM，CLM…）模块的namelist设置，如cam模块变量输出频率见: <a href="https://www.cesm.ucar.edu/models/cesm1.1/cesm/doc/modelnl/nl_cam.html">CAM Component Model Namelist Variables</a><br>以user_nl_cam为例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;history文件中所有变量的平均输出标志，两个值表示同时两种设置</span><br><span class="line">avgflag_pertpe = &#x27;A&#x27;,&#x27;A&#x27;</span><br><span class="line"></span><br><span class="line">;数组，各history文件序列的输出频率，第一个为0表示月平均，往后i大于0表示n个时步，小于0表示n小时</span><br><span class="line">nhtfrq = 0,-24  </span><br><span class="line"></span><br><span class="line">;数组，样本写入历史文件h0的最大次数，第一个数表示主历史文件，2-6表示辅助历史文件</span><br><span class="line">mfilt  = 1,1 </span><br><span class="line"></span><br><span class="line">;第一个历史文件 h0 包括的变量场</span><br><span class="line">fincl1= &#x27;T&#x27;,&#x27;TMQ&#x27;,&#x27;TS&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;Z3&#x27; </span><br><span class="line"></span><br><span class="line">;第二个历史文件 h1 包括的变量场</span><br><span class="line">fincl2 = &#x27;FLDS&#x27;,&#x27;FLNS&#x27;,&#x27;FLNT&#x27;,&#x27;OMEGA&#x27;,&#x27;PSL&#x27;,&#x27;PS&#x27;,&#x27;RELHUM&#x27;,&#x27;Q&#x27;,&#x27;SHFLX&#x27;,&#x27;T&#x27;,&#x27;TMQ&#x27;,&#x27;TS&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;Z3&#x27;          </span><br></pre></td></tr></table></figure><p>修改后查询结果：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./preview_namelist </span><br></pre></td></tr></table></figure><p>然后在 CaseDocs&#x2F;atm_in 查看设置的上述变量是否出现  </p><h5 id="运行并查看当前运行状态"><a href="#运行并查看当前运行状态" class="headerlink" title="运行并查看当前运行状态"></a>运行并查看当前运行状态</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coarse_amip.run</span><br></pre></td></tr></table></figure><p>当前运行状态位于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$CESMROOT</span>/<span class="variable">$CASENAME</span>/run/xxx.log.yymmdd-hhmmss</span><br></pre></td></tr></table></figure><p>如 cesm1_1&#x2F;coarse_amip&#x2F;run&#x2F;atm.log.220520-145438 模式积分完成后会被删除</p><h5 id="运行结束"><a href="#运行结束" class="headerlink" title="运行结束"></a>运行结束</h5><p><a href="https://www.cesm.ucar.edu/models/cesm1.0/filename_conventions_cesm.html">CCSM4&#x2F;CESM1 OUTPUT FILENAME REQUIREMENTS</a><br>文件储存分为 <strong>short-term archiving</strong> 和 <strong>long-term archiving</strong> ,分别通过 <strong>env_run.xml</strong> 中 <strong>$DOUT_S</strong> 和 <strong>$DOUT_L_MS</strong> 来控制，输出路径分别为 <strong>$DOUT_S_ROOT</strong> 、 <strong>$DOUT_L_MSROOT</strong><br>模式输出文件位于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$CESMROOT</span>/<span class="variable">$CASENAME</span>/output/xxx/</span><br></pre></td></tr></table></figure><p>其中XXX表示如atm,ocn,ice等的分量模式输出<br>再下一级目录的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist/ init/ logs/ rest/</span><br></pre></td></tr></table></figure><p>表示history,initial,logs,restart文件<br>在 <strong>CaseStatus</strong> 中最后一行看到 <strong>run SUCCESSFUL</strong> 并在相应路径有nc文件输出即为成功</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h4 id="如果出现-Can’t-locate-Switch-pm-in-INC-则是因为Perl5-1以上的版本问题，只需将已有的Switch-pm-文件复制到INC中一个路径即可"><a href="#如果出现-Can’t-locate-Switch-pm-in-INC-则是因为Perl5-1以上的版本问题，只需将已有的Switch-pm-文件复制到INC中一个路径即可" class="headerlink" title="如果出现 Can’t locate Switch.pm in @INC  则是因为Perl5.1以上的版本问题，只需将已有的Switch.pm 文件复制到INC中一个路径即可"></a>如果出现 <strong>Can’t locate Switch.pm in @INC</strong>  则是因为<strong>Perl5.1</strong>以上的版本问题，只需将已有的<strong>Switch.pm</strong> 文件复制到INC中一个路径即可</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /opt/intel/oneapi/compiler/2021.2.0/linux/lib/oclfpga/host/linux64/bin/perl/lib/site_perl/5.30.3/Switch.pm /usr/share/perl/5.30/</span><br></pre></td></tr></table></figure><h4 id="无gmake的情况：ubuntu上取消了gmake（GNUmake），用make代替即可"><a href="#无gmake的情况：ubuntu上取消了gmake（GNUmake），用make代替即可" class="headerlink" title="无gmake的情况：ubuntu上取消了gmake（GNUmake），用make代替即可"></a>无gmake的情况：ubuntu上取消了gmake（GNUmake），用make代替即可</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/make /usr/bin/gmake</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;开始之前先要安装库以及相应软件，过程省略，具体在官网：&lt;br&gt;&lt;a href=&quot;https://www.cesm.ucar.edu/mode</summary>
      
    
    
    
    <category term="Linux" scheme="https://ihjj.cn/categories/Linux/"/>
    
    
    <category term="Model" scheme="https://ihjj.cn/tags/Model/"/>
    
    <category term="Software" scheme="https://ihjj.cn/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 20.04下 netcdf库的安装</title>
    <link href="https://ihjj.cn/2022/03/28/Ubuntu-20-04%E4%B8%8B-netcdf%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://ihjj.cn/2022/03/28/Ubuntu-20-04%E4%B8%8B-netcdf%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2022-03-28T03:10:45.000Z</published>
    <updated>2022-09-02T09:43:04.639Z</updated>
    
    <content type="html"><![CDATA[<p>针对ifort或是gfortran编译器<br>首先切换root用户</p><h5 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h5><h6 id="对于ifort"><a href="#对于ifort" class="headerlink" title="对于ifort"></a>对于ifort</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/intel/oneapi/setvars.sh intel64    <span class="comment"># 来自intel官方安装说明 将ifort命令添加到环境变量中</span></span><br><span class="line"><span class="built_in">export</span> NETCDF=/usr/local/netcdf-ifort   <span class="comment">#--------------&amp;gt;所有库将被安装到这个路径中</span></span><br><span class="line"><span class="built_in">export</span> CC=icc</span><br><span class="line"><span class="built_in">export</span> CXX=icpc</span><br><span class="line"><span class="built_in">export</span> FC=ifort</span><br><span class="line"><span class="built_in">export</span> F90=ifort</span><br><span class="line"><span class="built_in">export</span> F77=ifort</span><br></pre></td></tr></table></figure><h6 id="对于gfortran"><a href="#对于gfortran" class="headerlink" title="对于gfortran"></a>对于gfortran</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> F77=gfortran</span><br><span class="line"><span class="built_in">export</span> FC=gfortran</span><br><span class="line"><span class="built_in">export</span> CC=gcc</span><br><span class="line"><span class="built_in">export</span> CXX=g++</span><br><span class="line"><span class="built_in">export</span> CFLAGS=-fPIC</span><br></pre></td></tr></table></figure><hr><h5 id="安装netcdf库所需依赖"><a href="#安装netcdf库所需依赖" class="headerlink" title="安装netcdf库所需依赖"></a>安装netcdf库所需依赖</h5><h6 id="ZLIB"><a href="#ZLIB" class="headerlink" title="ZLIB"></a>ZLIB</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> zlib-1.2.8/</span><br><span class="line">./configure --prefix=<span class="variable">$&#123;NETCDF&#125;</span></span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h6 id="hdf5"><a href="#hdf5" class="headerlink" title="hdf5"></a>hdf5</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../hdf5-1.10.5/</span><br><span class="line">./configure --with-zlib=<span class="variable">$&#123;NETCDF&#125;</span> --prefix=<span class="variable">$&#123;NETCDF&#125;</span></span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h6 id="netcdf-c"><a href="#netcdf-c" class="headerlink" title="netcdf-c"></a>netcdf-c</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../netcdf-c*</span><br><span class="line">CPPFLAGS=-I<span class="variable">$&#123;NETCDF&#125;</span>/include LDFLAGS=-L<span class="variable">$&#123;NETCDF&#125;</span>/lib ./configure --prefix=<span class="variable">$&#123;NETCDF&#125;</span> --enable-netcdf-4 --enable-largefile --disable-dap</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h6 id="netcdf-fortran"><a href="#netcdf-fortran" class="headerlink" title="netcdf-fortran"></a>netcdf-fortran</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../netcdf-fortran*</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;NETCDF&#125;</span>/lib:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span></span><br><span class="line">CPPFLAGS=-I<span class="variable">$&#123;NETCDF&#125;</span>/include LDFLAGS=-L<span class="variable">$&#123;NETCDF&#125;</span>/lib  ./configure --prefix=<span class="variable">$&#123;NETCDF&#125;</span> --disable-fortran-type-check</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><hr><h5 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h5><p>将以下部分添加到~&#x2F;.bashrc文件中并测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netcdf</span></span><br><span class="line"><span class="built_in">export</span> NETCDF=/usr/local/netcdf-ifort</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;NETCDF&#125;</span>/bin:<span class="variable">$&#123;PATH&#125;</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;NETCDF&#125;</span>/lib:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=-I<span class="variable">$&#123;NETCDF&#125;</span>/include</span><br><span class="line"><span class="built_in">export</span> LDFLAGS=-L<span class="variable">$&#123;NETCDF&#125;</span>/lib</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*********netcdf for ifort activated*********&quot;</span></span><br></pre></td></tr></table></figure><p>以下是测试是否安装成功的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifort -o a.out xxx.F90 -I<span class="variable">$&#123;NETCDF&#125;</span>/include -L<span class="variable">$&#123;NETCDF&#125;</span>/lib -lnetcdff  -lnetcdf</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;针对ifort或是gfortran编译器&lt;br&gt;首先切换root用户&lt;/p&gt;
&lt;h5 id=&quot;环境变量设置&quot;&gt;&lt;a href=&quot;#环境变量设置&quot; class=&quot;headerlink&quot; title=&quot;环境变量设置&quot;&gt;&lt;/a&gt;环境变量设置&lt;/h5&gt;&lt;h6 id=&quot;对于ifort</summary>
      
    
    
    
    <category term="Linux" scheme="https://ihjj.cn/categories/Linux/"/>
    
    
    <category term="Software" scheme="https://ihjj.cn/tags/Software/"/>
    
  </entry>
  
</feed>
