{"meta":{"title":"Astro的踩坑记录","subtitle":"","description":" Welcome","author":"Junjie Huang","url":"https://ihjj.cn","root":"/"},"pages":[{"title":"About Me","date":"2022-05-21T07:59:41.000Z","updated":"2022-09-02T09:43:04.639Z","comments":true,"path":"about/index.html","permalink":"https://ihjj.cn/about/index.html","excerpt":"","text":"mail: &#49;&#x39;&#53;&#57;&#48;&#53;&#x39;&#53;&#57;&#x36;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;"}],"posts":[{"title":"Docker 笔记","slug":"Docker笔记","date":"2022-09-02T10:26:34.403Z","updated":"2022-09-02T10:26:34.403Z","comments":true,"path":"2022/09/02/Docker笔记/","link":"","permalink":"https://ihjj.cn/2022/09/02/Docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Dcoker是什么容器化技术 直接运行在操作系统上（宿主机内核中）没有虚拟硬件 内核级别虚拟化 轻便 每个容器间互相隔离 各有自己的文件系统 通过镜像生成容器所有docker镜像都是只读，在镜像启动时加载一个新的可写层至镜像层顶部，即为容器层。 Docker入门命令命令概览所有命令可在Docker命令官方文档中查询 12#一条通用原则docker cmd --help # 查看cmd支持的常用命令 完整版在官方文档搜索 123456789101112131415docker info #显示docker系统信息 包括镜像、容器数量docker search xxx # 查询镜像docker run 镜像id [cmd] # 生成容器并运行命令docker ps # 查看所有容器docker images # 查看所有镜像docker top 容器id # 查看容器内进程docker inspect 容器id # 查看容器所有信息 包括容器内的默认环境...docker rm xxx # 删除容器docker rmi xxx # 删除镜像（i-&gt;images）docker start/restart/stop/kill 容器id #开启/重启/结束/关闭 容器docker logs #查看log文件docker history 镜像id #查看镜像创建的历史及步骤docker stats #查看所有容器的cpu占用等信息docker commmit -m=&quot;commited_information&quot; -a=&quot;author_name&quot; 容器id name:tagdocker push #发布镜像（docker hub 阿里云） 进入容器后 12exit # 退出并关闭容器ctrl+p+q # 退出容器 保持后台运行 通常将容器放在后台运行，此时如果需要进入当前正在运行的容器 123docker exec -it 容器id 进入后执行的命令 #(通常执行bash) #或docker attach 容器id #如果容器正在执行文件或有持续输出，则持续显示输出信息 1 关于宿主机与容器的文件交换1234567# 1. 手动从容器拷贝文件到主机（只要容器在数据就在，无论是否运行，即docker ps -a存在即可）：# 先进入容器docker attach 容器id #然后复制文件docker cp 容器id:/path/of/docker /path/of/linux# 2. 在创建容器时挂载文件到容器内，实现双向同步docker run -it -v /path/of/local:/path/of/docker 镜像名称 bash 数据共享（目录挂载）时，将容器内的目录挂载到linux上，以实现容器的持久化和同步操作。容器之间的数据也可以共享。可通过以下方式查看挂载信息 123456789101112131415docker inspect 容器id[... &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/hjj&quot;, &quot;Destination&quot;: &quot;/tmp&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125; ],...] -v后宿主机路径与容器路径会绑定，若本机不存在此路径则新建，文件双向绑定同步，即使exit退出容器只要镜像还在(docker ps -a)即可在本地修改文件并在容器中同步。即使删除容器，改变的数据文件已存在本地，所以不会丢失。通过以下命令重新进入容器 12docker start 容器iddocker attatch 容器id 文件挂载的两种方式匿名挂载12-v 容器内路径docker volume ls # 查看所有卷，由于-v之后为给定本机路径，因此输出的 VOLUME NAME 为英文+数子的长字符串 具名挂载 （常用）12-v name:容器内路径 # name中不包含/，否则表示本机路径 docker volume inspect name #查看卷 12-v /path/of/local:容器内路径 #表示指定路径挂载# 未指定目录的情况下挂载在本机/var/lib/docker 容器内路径后可通过 :ro rw 来改变读写权限，表示只读&#x2F;只写，ro表示容器中此路径只能通过宿主机操作 DockerfileDockerfile官方说明用于构建docker的构建文件，为命令脚本,通过docker build构建成为镜像。很多官方镜像都是基础包（FROM scratch)，缺乏很多功能如vim，因此通常自己制作镜像。面向开发，通常用于发布项目&#x2F;做镜像，镜像已逐渐成为企业交付的标准。DockerImages通过DockerFile生成的镜像 最终发布和运行的产品。Dockerfile中关键字建议大写，指令小写，用 # 注释。 123456789101112FROM # 基础镜像 从此开始构建MAINTAINER # 维护者 姓名➕邮箱RUN # 构建镜像时需要运行的命令ADD # 可将压缩包自动解压到容器指定路径下 ADD xxx.tgz /pathWORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 同-p 暴露端口CMD # 指定容器启动时运行的命令 只有最后一个会生效，可被替代 可通过&amp;&amp;执行多个命令ENTRYPOINT # 指定容器启动时运行的命令 可以追加ONBUILD # 当构建一个被继承的dockerfile时，ONBUILD就会运行COPY # 类似ADD 将文件拷贝到镜像中ENV # 构建时设置环境变了 通过以下命令创建镜像。注意最后的 . 表示当前路径不要遗漏。 1docker build -f dockerfile_name -t 镜像名[:tag] . 若命名为Dockerfile可省去-f dockerfile_name的指令。 Dockerfile中CMD与ENTRYPOINT区别对于dockerfile创建的镜像，可通过以下命令来指定运行容器后需要执行的命令： 1docker run 镜像id [cmd] 此cmd会覆盖Dockefile中CMD指定的命令，而对于ENTRYPOINT指定的命令，cmd会追加在命令后执行，不会忽略。 镜像发布可将打包好的镜像发布至 docker官网镜像网站 供他人下载，也可以在此寻找别人打包好的镜像。在提交到hub之前必须给镜像加上tag: 1docker tag SOURCE_IMAGE[:TAG] hub_username/TARGET_IMAGE[:TAG] hub_username为docker账号的用户名，且提交前必须在镜像前加上此字段，然后: 1docker push hub_username/TARGET_IMAGE[:TAG] 即可在镜像网站中登陆查看到。也可以推送至阿里云（收费托管） 个人常用命令从tensorflow官网拉取镜像运行tf-GPU(若GPU设备足够(算力(Compute Capability)大于5.2)可使用NVIDIA-docker官网的TensorFlow镜像): 1docker run --gpus all -it --rm -v $PWD:/tmp -w /tmp tensorflow/tensorflow:latest-gpu bash 需要手动安装scipy&#x2F;matplotlib&#x2F;vim等库&#x2F;软件 1234567docker ps -a #正在以及历史运行的容器docker ps -a -n=1 #只显示一个docker ps -aq -n=1 #只显示一个并只显示iddocker rm -f $(docker ps -aq) #查询所有容器id并逐个删除容器docker logs -tf -tail n #带时间戳查看最新n个log 踩坑记录1docker run -d 镜像名 # 对于某些镜像，在docker ps时不会找到，因为后台运行时必须要有一个前台进程 否则docker发现没有应用会自动停止","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ihjj.cn/categories/Linux/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://ihjj.cn/tags/Software/"}]},{"title":"Ubuntu 20.04 下cesm1.1 的移植与测试","slug":"CESM_1.1","date":"2022-05-23T02:50:35.000Z","updated":"2022-09-02T10:07:31.211Z","comments":true,"path":"2022/05/23/CESM_1.1/","link":"","permalink":"https://ihjj.cn/2022/05/23/CESM_1.1/","excerpt":"","text":"前言开始之前先要安装库以及相应软件，过程省略，具体在官网：CESM1.1.z User’s GuideCESM Software&#x2F;Operating System Prerequisites.CESM各个版本：CESM Models也可在github中下载:GitHub-ESCOMP&#x2F;CESM: The Community Earth System ModelThe Community Earth System Model. 正文本文重点在于source code移植后的修改配置部分假设模式位于 cesm1_1&#x2F;需要修改的文件均位于 cesm1_1&#x2F;scripts&#x2F;ccsm_utils&#x2F;Machines 路径下 config_machines.xml主要是修改关于机器的配置添加以下部分 （根据自己服务器的配置&#x2F;环境来配置。具体各项意义可见官网CESM Models | CESM1.1 Public Release） 12345678910111213141516&lt;machine MACH=&quot;ubuntu&quot;&gt; &lt;DESC&gt;my ubuntu 20.04&lt;/DESC&gt; &lt;OS&gt;LINUX&lt;/OS&gt; &lt;COMPILERS&gt;intel,pgi,gnu,pathscale&lt;/COMPILERS&gt; &lt;MPILIBS&gt;mpich,mpi,pempi,mpi-serial&lt;/MPILIBS&gt; &lt;RUNDIR&gt;/xxxxxxxxx/cesm1_1/$CASE/run&lt;/RUNDIR&gt; &lt;EXEROOT&gt;/xxxxxxxx/cesm1_1/$CASE/bld&lt;/EXEROOT&gt; &lt;DIN_LOC_ROOT&gt;/xxxxxx/Cesm_data/inputdata&lt;/DIN_LOC_ROOT&gt;&lt;DIN_LOC_ROOT_CLMFORC&gt;xxxxxxx/Cesm_data/tss&lt;/DIN_LOC_ROOT_CLMFORC&gt; &lt;DOUT_S_ROOT&gt;xxxxxx/cesm1_1/$CASE/output&lt;/DOUT_S_ROOT&gt; &lt;DOUT_L_MSROOT&gt;csm/$CASE&lt;/DOUT_L_MSROOT&gt;&lt;CCSM_BASELINE&gt;$ENV&#123;CESMDATAROOT&#125;/ccsm_baselines&lt;/CCSM_BASELINE&gt;&lt;CCSM_CPRNC&gt;$ENV&#123;CESMDATAROOT&#125;/tools/cprnc/cprnc&lt;/CCSM_CPRNC&gt; &lt;BATCHQUERY&gt;USERDEFINED_optional_run&lt;/BATCHQUERY&gt; &lt;BATCHSUBMIT&gt;USERDEFINED_optional_run&lt;/BATCHSUBMIT&gt;&lt;SUPPORTED_BY&gt;USERDEFINED_optional_run&lt;/SUPPORTED_BY&gt; &lt;GMAKE_J&gt;1&lt;/GMAKE_J&gt; &lt;MAX_TASKS_PER_NODE&gt;2&lt;/MAX_TASKS_PER_NODE&gt; &lt;PES_PER_NODE&gt;1&lt;/PES_PER_NODE&gt;&lt;/machine&gt; config_compilers.xml关于编译器的配置添加以下部分 12345678910111213&lt;compiler COMPILER=&quot;intel&quot; MACH=&quot;ubuntu&quot;&gt; &lt;NETCDF_PATH&gt;$(NETCDF)&lt;/NETCDF_PATH&gt; &lt;MPICC&gt;mpiicc&lt;/MPICC&gt; &lt;MPIFC&gt;mpiifort&lt;/MPIFC&gt; &lt;MPICXX&gt;mpicpc&lt;/MPICXX&gt; &lt;SFC&gt;ifort&lt;/SFC&gt; &lt;SCC&gt;icc&lt;/SCC&gt; &lt;SCXX&gt;icpc&lt;/SCXX&gt; &lt;MPI_PATH MPILIB=&quot;mpich&quot;&gt; /opt/intel/oneapi/mpi/2021.2.0&lt;/MPI_PATH&gt; &lt;MPI_PATH MPILIB=&quot;openmpi&quot;&gt; /opt/intel/oneapi/mpi/2021.2.0&lt;/MPI_PATH&gt; &lt;HDF5_PATH&gt;$(NETCDF)&lt;/HDF5_PATH&gt; &lt;ADD_SLIBS&gt; -L$(NETCDF_PATH)/lib -lnetcdff -lnetcdf -L$(HDF5_PATH)/lib -lhdf5 -lhdf5_hl &lt;/ADD_SLIBS&gt;&lt;/compiler&gt; env_mach_specific.userdefined将 env_mach_specific.userdefined 复制为 env_mach_specific.ubuntu点后面（ubuntu）为之前设置的MACH名称添加以下部分，注意 set 后面有&#x3D;，且&#x3D;前后有空格。setenv没有等号，只有空格 123456set NETCDF_PATH = /usr/local/netcdf-ifortset MPI_PATH = /opt/intel/oneapi/mpi/2021.2.0setenv INC_NETCDF $&#123;NETCDF_PATH&#125;/includesetenv LIB_NETCDF $&#123;NETCDF_PATH&#125;/libsetenv INC_MPI $&#123;MPI_PATH&#125;/includesetenv LIB_MPI $&#123;MPI_PATH&#125;/lib mkbatch.userdefined将 mkbatch.userdefined 复制为 mkbatch.ubuntu点后面依旧是之前设置的MACH名称根据服务器提交作业的方式把qname&#x3D;batch 为自己服务器的脚本提交方式，如 qname&#x3D;qnormal，并把下方##的代码根据提交任务的脚本 去掉注释即可 （包括mpirun等等命令所在的行) 完成移植，进行测试。测试1此测试来自官方网站：Use Cases and FAQs 1234567cd cesm1_1/scripts./create_newcase -case case_official \\ -compset B_1850_CN \\ -res 0.9x1.25_gx1v6 \\ -mach ubuntu cd case_official/ 此时可根据需要修改运行配置如大气模式用到的核数 NTASKS_ATM ….. （当前该变量值可通过以下命令查询到。） 1./xmlquery NTASKS_ATM 对于修改诸如模式要用的核数NTASKS_xxxxx、线程数NTHRDS_xxx等等env_mach_pes.xml中的变量，必须在.&#x2F;cesm_setup之前修改，如果setup之后修改，必须先.&#x2F;cesm_setup -clean，修改，然后重新.&#x2F;cesm_setup。对于诸如任务重新提交时间STOP_OPTION等等其他变量，可在.&#x2F;cesm_setup之后修改两种修改方式： 11 ./xmlchange NTASKS_ATM=64 （等价于 ./xmlchange -file env_mach_pes.xml -id NTASKS_ATM -val 64） 2 直接vim修改env_mach_pes.xml 或是其余xml文件同上，所有与运行相关的配置变量可在CESM Models | CESM1.1 Public Release通过对应xml文件查找到。 12./cesm_setup./case_official.build 生成测试脚本（测试本例子能否跑通） 12345./create_production_testcd ../case_official_ERT./case_official_ERT.test_build./case_official_ERT.testcat CaseStatus (官网为 cat TestStatus ，以实际为准) 如果没有问题（PASS）即可进行下一步 1234cd ../case_official./xmlchange STOP_OPTION=nmonths 注意修改方式与官网给出的不一致./xmlchange STOP_N=12bsub &lt; case_official.run 提交作业方法因服务器而异 之后可在out文件中查看是否成功 测试2创建一个分辨率为10&amp;deg;x15&amp;deg;，只运行大气模块的试验1234./create_newcase -case coarse_amip -compset FAMIPC5 -res 10x15_10x15 -mach ubuntucd coarse_amip./cesm_setup./coarse_amip.build 生成测试的试运行脚本12345./create_production_testcd ../coarse_amip._ERT./coarse_amip_ERT.build./coarse_amip_ERT.runcat TestStatus 修改运行设置1cd ../coarse_amip 设置例如积分时长，运行月份，变量输出频率的配置对于自定义输出，可见: CAM: How do I customize CAM output fields?在 user_nl_xxx 中修改xxx（如CAM，CLM…）模块的namelist设置，如cam模块变量输出频率见: CAM Component Model Namelist Variables以user_nl_cam为例: 1234567891011121314;history文件中所有变量的平均输出标志，两个值表示同时两种设置avgflag_pertpe = &#x27;A&#x27;,&#x27;A&#x27;;数组，各history文件序列的输出频率，第一个为0表示月平均，往后i大于0表示n个时步，小于0表示n小时nhtfrq = 0,-24 ;数组，样本写入历史文件h0的最大次数，第一个数表示主历史文件，2-6表示辅助历史文件mfilt = 1,1 ;第一个历史文件 h0 包括的变量场fincl1= &#x27;T&#x27;,&#x27;TMQ&#x27;,&#x27;TS&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;Z3&#x27; ;第二个历史文件 h1 包括的变量场fincl2 = &#x27;FLDS&#x27;,&#x27;FLNS&#x27;,&#x27;FLNT&#x27;,&#x27;OMEGA&#x27;,&#x27;PSL&#x27;,&#x27;PS&#x27;,&#x27;RELHUM&#x27;,&#x27;Q&#x27;,&#x27;SHFLX&#x27;,&#x27;T&#x27;,&#x27;TMQ&#x27;,&#x27;TS&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;Z3&#x27; 修改后查询结果： 1./preview_namelist 然后在 CaseDocs&#x2F;atm_in 查看设置的上述变量是否出现 运行并查看当前运行状态1./coarse_amip.run 当前运行状态位于 1$CESMROOT/$CASENAME/run/xxx.log.yymmdd-hhmmss 如 cesm1_1&#x2F;coarse_amip&#x2F;run&#x2F;atm.log.220520-145438 模式积分完成后会被删除 运行结束CCSM4&#x2F;CESM1 OUTPUT FILENAME REQUIREMENTS文件储存分为 short-term archiving 和 long-term archiving ,分别通过 env_run.xml 中 $DOUT_S 和 $DOUT_L_MS 来控制，输出路径分别为 $DOUT_S_ROOT 、 $DOUT_L_MSROOT模式输出文件位于 1$CESMROOT/$CASENAME/output/xxx/ 其中XXX表示如atm,ocn,ice等的分量模式输出再下一级目录的 1hist/ init/ logs/ rest/ 表示history,initial,logs,restart文件在 CaseStatus 中最后一行看到 run SUCCESSFUL 并在相应路径有nc文件输出即为成功 踩坑记录如果出现 Can’t locate Switch.pm in @INC 则是因为Perl5.1以上的版本问题，只需将已有的Switch.pm 文件复制到INC中一个路径即可1sudo cp /opt/intel/oneapi/compiler/2021.2.0/linux/lib/oclfpga/host/linux64/bin/perl/lib/site_perl/5.30.3/Switch.pm /usr/share/perl/5.30/ 无gmake的情况：ubuntu上取消了gmake（GNUmake），用make代替即可1sudo ln -s /usr/bin/make /usr/bin/gmake","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ihjj.cn/categories/Linux/"}],"tags":[{"name":"Model","slug":"Model","permalink":"https://ihjj.cn/tags/Model/"},{"name":"Software","slug":"Software","permalink":"https://ihjj.cn/tags/Software/"}]},{"title":"Ubuntu 20.04下 netcdf库的安装","slug":"Ubuntu-20-04下-netcdf库的安装","date":"2022-03-28T03:10:45.000Z","updated":"2022-09-02T09:43:04.639Z","comments":true,"path":"2022/03/28/Ubuntu-20-04下-netcdf库的安装/","link":"","permalink":"https://ihjj.cn/2022/03/28/Ubuntu-20-04%E4%B8%8B-netcdf%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"针对ifort或是gfortran编译器首先切换root用户 环境变量设置对于ifort1234567source /opt/intel/oneapi/setvars.sh intel64 # 来自intel官方安装说明 将ifort命令添加到环境变量中export NETCDF=/usr/local/netcdf-ifort #--------------&amp;gt;所有库将被安装到这个路径中export CC=iccexport CXX=icpcexport FC=ifortexport F90=ifortexport F77=ifort 对于gfortran12345export F77=gfortranexport FC=gfortranexport CC=gccexport CXX=g++export CFLAGS=-fPIC 安装netcdf库所需依赖ZLIB12345cd zlib-1.2.8/./configure --prefix=$&#123;NETCDF&#125;makemake checkmake install hdf512345cd ../hdf5-1.10.5/./configure --with-zlib=$&#123;NETCDF&#125; --prefix=$&#123;NETCDF&#125;makemake checkmake install netcdf-c12345cd ../netcdf-c*CPPFLAGS=-I$&#123;NETCDF&#125;/include LDFLAGS=-L$&#123;NETCDF&#125;/lib ./configure --prefix=$&#123;NETCDF&#125; --enable-netcdf-4 --enable-largefile --disable-dapmakemake checkmake install netcdf-fortran123456cd ../netcdf-fortran*export LD_LIBRARY_PATH=$&#123;NETCDF&#125;/lib:$&#123;LD_LIBRARY_PATH&#125;CPPFLAGS=-I$&#123;NETCDF&#125;/include LDFLAGS=-L$&#123;NETCDF&#125;/lib ./configure --prefix=$&#123;NETCDF&#125; --disable-fortran-type-checkmakemake checkmake install 安装完成将以下部分添加到~&#x2F;.bashrc文件中并测试 1234567# netcdfexport NETCDF=/usr/local/netcdf-ifortexport PATH=$&#123;NETCDF&#125;/bin:$&#123;PATH&#125;export LD_LIBRARY_PATH=$&#123;NETCDF&#125;/lib:$&#123;LD_LIBRARY_PATH&#125;export CPPFLAGS=-I$&#123;NETCDF&#125;/includeexport LDFLAGS=-L$&#123;NETCDF&#125;/libecho &quot;*********netcdf for ifort activated*********&quot; 以下是测试是否安装成功的方法 12ifort -o a.out xxx.F90 -I$&#123;NETCDF&#125;/include -L$&#123;NETCDF&#125;/lib -lnetcdff -lnetcdf./a.out","categories":[{"name":"Linux","slug":"Linux","permalink":"https://ihjj.cn/categories/Linux/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://ihjj.cn/tags/Software/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ihjj.cn/categories/Linux/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://ihjj.cn/tags/Software/"},{"name":"Model","slug":"Model","permalink":"https://ihjj.cn/tags/Model/"}]}